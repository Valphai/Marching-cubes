// // Each #kernel tells which function to compile; you can have many kernels
// #pragma kernel MarchingCube

// #include "./Includes/MarchTables.compute"
// #include "./Includes/IndexMap.compute"

// struct Triangle
// {
//     float3 vert0;
//     float3 vert1;
//     float3 vert2;
// };

// AppendStructuredBuffer<Triangle> Triangs;
// RWStructuredBuffer<float4> Positions;

// float IsoLevel;
// int Resolution;

// float3 InterpolateVertecies(float4 v1, float4 v2)
// {
//     float3 v;
//     float t = (IsoLevel - v1.w) / (v2.w - v1.w);

//     v.x = v1.x + t * (v2.x - v1.x);
//     v.y = v1.y + t * (v2.y - v1.y);
//     v.z = v1.z + t * (v2.z - v1.z);
//     return v;
// }
// [numthreads(8,8,8)]
// void MarchingCube(int3 id : SV_DispatchThreadID)
// {
//     float4 cubeCorners[8] = {
//         Positions[Map3dIndexTo1d(id.x, id.y, id.z, Resolution)],
//         Positions[Map3dIndexTo1d(id.x, id.y + 1, id.z, Resolution)],
//         Positions[Map3dIndexTo1d(id.x + 1, id.y + 1, id.z, Resolution)],
//         Positions[Map3dIndexTo1d(id.x + 1, id.y, id.z, Resolution)],
//         Positions[Map3dIndexTo1d(id.x, id.y, id.z + 1, Resolution)],
//         Positions[Map3dIndexTo1d(id.x, id.y + 1, id.z + 1, Resolution)],
//         Positions[Map3dIndexTo1d(id.x + 1, id.y + 1, id.z + 1, Resolution)],
//         Positions[Map3dIndexTo1d(id.x + 1, id.y, id.z + 1, Resolution)],
//     };

//     // Calculate the index of the current cube configuration
//     // the for loop maps cubeIndex to [0,255]
//     int cubeIndex = 0;
//     for (int i = 0; i < 8; i++)
//     {
//         if (cubeCorners[i].w < IsoLevel)
//         {
//             cubeIndex |= 1 << i;
//         }
//     }

//     // Looping over each edge sum that make up a triangle
//     // Func<int, int> edgeIndexOfTheCube = i => triTable[cubeIndex, i];
//     for (int j = 0; triTable[cubeIndex][j] != -1; j += 3)
//     {
//         int cornIndexA0 = CornerIndexFromEdge[triTable[cubeIndex][j]][0];
//         int cornIndexB0 = CornerIndexFromEdge[triTable[cubeIndex][j]][1];

//         int cornIndexA1 = CornerIndexFromEdge[triTable[cubeIndex][j + 1]][0];
//         int cornIndexB1 = CornerIndexFromEdge[triTable[cubeIndex][j + 1]][1];

//         int cornIndexA2 = CornerIndexFromEdge[triTable[cubeIndex][j + 2]][0];
//         int cornIndexB2 = CornerIndexFromEdge[triTable[cubeIndex][j + 2]][1];

//         Triangle tri;
//         tri.vert0 = InterpolateVertecies(cubeCorners[cornIndexA0], cubeCorners[cornIndexB0]);
//         tri.vert1 = InterpolateVertecies(cubeCorners[cornIndexA1], cubeCorners[cornIndexB1]);
//         tri.vert2 = InterpolateVertecies(cubeCorners[cornIndexA2], cubeCorners[cornIndexB2]);
        
//         Triangs.Append(tri);
//     }
// }